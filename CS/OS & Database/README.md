# Operating System & Database

## OS

### 프로세스와 스레드

  프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고 스레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위입니다. 프로세스는 실행될 때 운영체제로부터 프로세서, 필요한 주소 공간, 메모리 등 자원을 할당받습니다. 스레드란 한 프로세스 내에서 동작되는 여러 실행의 흐름으로 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내에 스레드끼리 공유하면서 실행됩니다.

 그렇다면 왜 멀티 프로세스로 할 수 있는 작업들을 굳이 하나의 프로세스에서 스레드로 나눠가면서 할까요? 이유는 간단합니다. 운영체제는 시스템 자원을 효율적으로 관리하기 위해서 스레드를 사용하는 것입니다. 

 자세히 말하면 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다. 뿐만 아니라 프로세스 간의 통신보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어들게 됩니다.

 이처럼 스레드를 활용하면 자원의 효율성이 증가하기도 하지만 스레드 간의 자원 공유는 전역 변수를 이용하므로 동기화 문제에 신경을 써야 합니다.



### 뮤텍스(mutex)와 세마포어(Semaphore)

뮤텍스: 한 쓰레드, 프로세스에 의해 소유될 수 있는 Key를 기반으로 한 상호배제기법

 화장실 예시: 화장실이 하나 뿐이 없는 식당. 화장실을 가기 위해서는 카운터에서 열쇠를 받아 가야 한다. 당신이 화장실을 가려고 하는데 카운터에 키가 있으면 화장실에 사람이 없다는 뜻이고 당신은 그 열쇠를 이용해 화장실에 들어갈 수 있다. 당신이 화장실에서 행복한 시간을 보내고 있는데 다른 테이블에 있는 어떤 남자가 화장실에 가고 싶어졌다. 이 남자는 아무리 용무가 급하더라도 열쇠가 없기 때문에 화장실에 들어갈 수 없다. 결국 남자는 당신이 용무를 마친 후 나올 때까지 카운터에서 기다려야 한다. 이제 당신이 화장실에서 나와 카운터에 키를 돌려놓았다. 이제 기다리던 사람들 중 맨 앞에있던 사람은 키를 받을 수 있고 이를 이용해 화장실에 갈 수 있다. 이것이 뮤텍스가 동작하는 방식이다. 화장실을 이용하는 사람은 **프로세스 혹은 쓰레드**이며 화장실은 **공유자원**, 화장실 키는 공유자원에 접근하기 위해 필요한 어떤 오브젝트이다.

세마포어: Signaling mechanism. 현재 공유자원에 접근할 수 있는 쓰레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성하는 기법.

 화장실 예시: 세마포어는 손님이 화장실을 좀 더 쉽게 이용할 수 있는 레스토랑이다. 세마포어를 이용하는 레스토랑의 화장실에는 여러 개의 칸이 있다. 그리고 화장실 입구에는 현재 화장실의 빈 칸 개수를 보여주는 전광판이 있다. 만약 당신이 화장실에 가고 싶다면 입구에서 빈 칸의 개수를 확인하고 빈 칸이 1개 이상이라면 빈칸의 개수를 하나 뺀 다음에 화장실로 입장해야 한다. 그리고 나올 때 빈 칸의 개수를 하나 더해준다. 모든 칸에 사람이 들어갔을 경우 빈 칸의 개수는 0이 되며 이때 화장실에 들어가고자 하는 사람이 있다면 빈 칸의 개수가 1로 바뀔 때까지 기다려야 한다. 사람들은 나오면서 빈 칸의 개수를 1씩 더한다. 그리고 기다리던 사람은 이 숫자에서 다시 1을 뺀 다음 화장실로 돌진한다. 세마포어도 아까와 똑같이 화장실이 공유자원이며 사람들이 쓰레드, 프로세스이다. 그리고 화장실 빈칸의 개수는 현재 공유자원에 접근할 수 있는 쓰레드,프로세스의 개수를 나타낸다.

출처: https://worthpreading.tistory.com/90 [Worth spreading]

### 교착상태(Deadlock)

[참고](https://jwprogramming.tistory.com/12)



## 데이터베이스

### DBMS(Database Management System)

 다수의 컴퓨터 사용자들이 컴퓨터에 수록된 수 많은 자료들을 쉽고 빠르게 추가, 수정, 삭제할 수 있도록 해주는 시스템이다. DB내의 정보를 검색하거나 정보를 저장하기 편리하고 효율적인 환경을 제공하는 것이 목적.

| 분류                                              | 개념                                                         | 예시                         |
| ------------------------------------------------- | ------------------------------------------------------------ | ---------------------------- |
| DDL (데이터 정의 언어, Data Definition Language)  | 데이터를 정의하기 위한 언어. 관계형 데이터베이스 구조(테이블, 스키마)를 정의하기 위한 명령어이다. | CREATE DROP ALTER            |
| DML(데이터 조작 언어, Data Manipulation Language) | 데이터를 저장, 수정, 삭제, 조회 등을 하기 위한 언어이다.     | INSERT UPDATE DELETE SELECT  |
| DCL(데이터 제어 언어, Data Control Language)      | 데이터베이스 사용자의 권한 제어를 위해 사용되는 언어이다.    | GRANT REVOKE COMMIT ROLLBACK |



### JOIN

> 테이블 예시(A 테이블, B 테이블)

```
A 테이블	B 테이블
과일		과일
---		 ---
사과		멜론
수박		참외
멜론		딸기
참외		자두
```

> Inner join

두 테이블의 교집합을 얻습니다. 

```
SELECT * FROM A INNER JOIN B ON A.과일 = B.과일;

(결과)
A | B
--+--
멜론 | 멜론
참외 | 참외
```

> Left outer join

Left outer join은 A에 있는 모든 행과 B에 함께 있는 행을 얻습니다.

```
SELECT * FROM A LEFT OUTER JOIN B ON A.과일 = B.과일;

(결과)
A | B
--+--
사과 | null
수박 | null
멜론 | 멜론
참외 | 참외
```

> Full outer join

Full outer join은 A와 B의 합집합을 얻습니다. 만약 어떤 행의 A에는 데이터가 있고, B에는 비어있는 경우 B 부분은 null이며, 반대의 경우에는 A 부분이 null입니다.

```
SELECT * FROM A FULL OUTER JOIN B ON A.과일 = B.과일;

(결과)
A | B
--+--
사과 | null
수박 | null
멜론 | 멜론
참외 | 참외
null | 딸기
null | 자두
```



### ORM(Object Relational Mapping)

 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 것을 말한다. 객체지향프로그래밍은 클래스를 사용하고, 관계형 데이터베이스는 테이블을 사용한다. 객체 모델과 관계형 모델 간에 불일치가 존재하는데 ORM을 통해 객체 관의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결한다.



### 트랜잭션

 트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.

>  트랜잭션의 성질

ACID(Atomicity, Consistency, Isolation, Durability)

> 트랜잭션 연산

Commit 연산: 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다.

Rollback 연산: 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산이다. Rollback 시에는 해당 트랜잭션을 재시작하거나 폐기한다.

> 트랜잭션의 상태

활동(Active) : 트랜잭션이 실행중인 상태

실패(Failed) : 트랜잭션 실행에 오류가 발생하여 중단된 상태

철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태

부분 완료(Partially Committed) : 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태

완료(Committed) : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태



### ACID

Atomicity: 원자성. 완료되지 않은 트랜잭션의 중간 상태를 데이터베이스에 반영하면 안된다.

Consistency: 일관성. 고립된 트랜잭션의 수행이 데이터베이스의 일관성을 보존해야 한다.

Isolation: 고립성. 여러 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션의 수행에 영향을 받지 않고 독립적으로 수행되어야 한다.

Durability: 지속성. 트랜잭션이 성공적으로 완료되어 커밋되고 나면 해당 트랜잭션에 의한 모든 변경은 향후에 어떤 소프트웨어나 하드웨어 장애가 발생되더라도 보존되어야 한다.



### 무결성(Integrity)

 데이터의 무결성은 데이터의 정확성, 일관성, 유효성이 유지되는 것을 말한다. 데이터의 무결성을 유지하는 것은 데이터베이스 관리시스템 (DBMS)의 중요한 기능이며, 주로 데이터에 적용되는 연산에 제한을 두어 데이터의 무결성을 유지한다. 데이터베이스에서 말하는 무결성에는 다음과 같은 4가지 종류가 있다.

1. 개체 무결성(Entity Integrity)

모든 테이블이 기본 키 (primary key)로 선택된 필드 (column)를 가져야 한다. 기본 키로 선택된 필드는 고유한 값을 가져야 하며, 빈 값은 허용하지 않는다.

2. 참조 무결성(Referential Integrity)

 관계형 데이터베이스 모델에서 참조 무결성은 참조 관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지되는 것을 말한다. 예를 들어 student 테이블이 department 테이블을 참조하고 있다고 가정하자. 만약 department 테이블에서 id 값이 310인 레코드가 삭제되면 이를 참고하는 student 테이블의 레코드는 더 이상 존재하지 않는 데이터를 참조하게 돼 참조 무결성이 깨지게 된다.

3. 도메인 무결성(Domain Integrity)

 도메인 무결성은 테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로 필드의 타입, NULL값의 허용 등에 대한 사항을 정의하고, 올바른 데이터의 입력 되었는지를 확인하는 것이다. 예를 들어, 주민등록번호 필드에 알파벳이 입력되는 경우는 도메인 무결성이 깨지는 경우라고 볼 수 있다. DBMS의 기본값 설정, NOT NULL 옵션 등의 제약 사항으로 도메인 무결성을 보장할 수 있다.

4. 무결성 규칙(Integrity rule)

 데이터베이스에서 무결성 규칙은 데이터의 무결성을 지키기 위한 모든 제약 사항들을 말한다. 비즈니스 규칙 (business rule)은 데이터베이스를 이용하는 각각의 유저에 따라 서로 다르게 적용되지만, 무결성 규칙은 데이터베이스 전체에 공통적으로 적용되는 규칙이다.



### 정규화

 자료의 손실이나 불필요한 정보의 도입 없이 데이터의 일관성, 데이터 중복을 최소화하고 최대의 데이터 안정성 확보를 위한 안정적 자료 구조로 변환하기 위해서 하나의 테이블을 둘 이상을 분리하는 작업이다.

정규화의 목적은

- 저장 공간 최소화
- 데이터 무결성 유지
- 자료구조의 안정성 최대화

이다.

어느 테이블이든 어느 정도는 정규화 될 수 있는데 데이터베이스 이론에서 테이블의 정규화된 정도를 정규형이라는 용어를 써서 표현한다.

![.](../images/nf.PNG)



### 뷰(View)

 뷰는 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상테이블이다. 뷰는 저장장치 내에 물리적으로 존재하지 않지만 사용자에게 있는 것처럼 간주되며 데이터 보정작업, 처리과정 시험 등 임시적인 작업을 위한 용도로 활용된다.

뷰는 기본테이블로부터 유도된 테이블이기 때문에 기본 테이블과 같은 형태의 구조를 사용하며, 조작도 기본 테이블과 거의 같다. 뷰는 가상 테이블이기 때문에 물리적으로 구현돼 있지는 않다.

> 뷰 생성 예시

```sql
--고객 테이블에서 주소가 서울시인 고객들의 성명과 전화번호를 서울고객이라는 뷰로 만들어라--
CREATE VIEW 서울고객(성명, 전화번호)
AS SELECT 성명 전화번호
FROM 고객
WHERE 주소 = '서울시';
```



### NoSQL

 Not Only SQL. RDBMS의 형태가 아닌 일관성 모델(비관계형 모델, Non-relational)을 이용하는 데이터베이스 형태. 복잡한 테이블들 간의 관계(relation)가 없으므로 고정된 형태의 스키마가 존재하지 않는다. 최적화된 Key-value 형식의 저장 공간의 사용한다.

NoSQL은 분산 환경에서 대용량의 데이터를 빠르게 처리하기 위해서 개발되었으며, 장점으로서 수평적 확장성(Horizontal Scalability)을 가져 데이터 추가가 용이하며 단점으로는 RDBMS와 달리 중복된 데이터를 다량 가지고 있을 수 있다는 점이다.

> RDBMS와 다른 점

- 스키마가 없다. 즉 데이터 관계와 정해진 규격(table-column의 정의)이 없다.
- 관계 정의가 없으니 Join이 불가능하다. (하지만 reference와 같은 기능으로 비슷하게 구현은 가능.)
- 트랜잭션을 지원하지 않는다.
- 분산처리(수평적 확장)의 기능을 쉽게 제공한다.
- 대부분의 NoSQL DB는 분산처리기능을 목적으로 나왔기 때문에 분산처리 기능을 자체 프레임워크에 포함하고 있다.



### Index

 DB에서 Index란 테이블에 저장된 데이터를 빠르게 조회하기 위한 데이터베이스 객체입니다. B-Tree 구조를 가지며 논리적, 물리적으로 테이블과는 독립적입니다. 

 Index를 사용하는 이유는

- 인덱스(Index)는 데이터를 논리적으로 정렬하여 검색과 정렬 작업의 속도를 높이기 위해 사용된다.
- 예를 들면, 책에서 가장 빨리 내용을 찾는 방법은 책의 뒤편의 색인을 보는 것.
- 기본키에 대해서는 항상 DBMS가 내부적으로 정렬된 목록을 관리하기에 특정 행을 가져올 때 빠르게 처리된다. 하지만, 다른 열의 내용을 검색하거나 정렬시에는 하나하나 대조를 해보기 때문에 시간이 오래걸린다. (이를 인덱스로 정의해두면 검색속도가 향상된다.)
- 단점: 인덱스를 사용하면 데이터를 가져오는 작업의 성능은 향상시킬 수 있지만 데이터 삽입, 변경 등이 일어날 때 매번 인덱스가 변경되기 때문에 성능이 떨어질 수 있다.
- 사용대상 : 데이터 필터링과 정렬에 사용되므로, 데이터를 특정한 순서로 자주 정렬한다면 인덱스를 사용하기에 적합



### Elasticsearch

 Elasticsearch는 텍스트, 숫자, 위치 기반 정보, 정형 및 비정형 데이터 등 모든 유형의 데이터를 위한 분산형 오픈 소스 검색 및 분석 엔진입니다.  

Elastcisearch의 속도와 확장성 그리고 수많은 종류의 콘텐츠를 Indexing할 수 있는 능력은 어플리케이션 검색, 웹사이트 검색, 로깅과 로그 분석, 모니터링, 데이터 분석 등에 사용할 수 있습니다.

Elasticsearch Index는 서로 관련되어 있는 문서들의 모음입니다. Elasticsearch는 JSON 문서로 데이터를 저장합니다. 각 문서는 일련의 키(필드나 속성의 이름)와 그에 해당하는 값(문자열, 숫자, 부울, 날짜, 값의 배열, 지리적 위치 또는 기타 데이터 유형)을 서로 연결합니다.

Elasticsearch는 반전된 Index라고 하는 데이터 구조를 사용하는데, 이것은 아주 빠른 전체 텍스트 검색을 할 수 있도록 설계된 것입니다. 반전된 Index는 문서에 나타나는 모든 고유한 단어의 목록을 만들고, 각 단어가 발생하는 모든 문서를 식별합니다.

Index 프로세스 중에, Elasticsearch는 문서를 저장하고 반전된 Index를 구축하여 거의 실시간으로 문서를 검색 가능한 데이터로 만듭니다. Index API를 사용해 색인이 시작되며, 이를 통해 사용자는 특정한 Index에서 JSON 문서를 추가하거나 업데이트할 수 있습니다.

