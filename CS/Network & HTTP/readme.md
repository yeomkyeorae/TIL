# Network

### 패킷(packet)

 네트워크 통신을 할 때 사용되는 작게 분할된 데이터 조각으로 네트워크에서 전송하는 데이터의 기본 단위이다.



### 인터넷 서비스 제공자(ISP, Internet Service Provider)

 인터넷에 접속하는 수단을 제공하는 주체다. 일반 사용자, 기업체, 기관, 단체 등이 인터넷에 접속하여 인터넷을 이용할 수 있도록 돕는 사업자다(KT, U+, SK브로드밴드 등).



### URI vs URL

 URI(Uniform Resource Identifier, 통합 자원 식별자), URL(Uniform Resource Locator, 통합 자원 위치)은 모두 인터넷 상에서 존재하는 어떤 자원(웹 문서, 이미지, pdf 파일 등)의 위치를 나타내는 주소이지만 URI가 URL을 포함하는 더 넓은 개념입니다.

```
1. http://www.test.com/index.html  -------------|
URI: O, URL: O									|
												|
												|----------- index.html
												|
												|
2. http://www.test.com/index -------- rewrite --|
URI: O, URL: X
```

두 주소 모두 index.html을 가리키고 있습니다.

1은 웹 서버의 실제 파일의 위치를 나타내는 주소 즉, URL이면서 URI입니다.

2는 웹서버에 실제로 index라는 파일은 존재하지 않기 때문에 URL은 아닙니다. 하지만 rewrite(rewrite를 통해 실제 웹 페이지의 파일 이름을 숨기는 경우가 많습니다)를 통해 index.html을 가리키고 있기 때문에 URI라고 볼 수 있습니다. (예시 : https://section.blog.naver.com/BlogHome.nhn에서 BlogHome.nhn이라는 파일은 실제로 네이버 서버에 존재하지 않을 것입니다. 그러미로 이는 URI입니다.)



### 프로토콜

 컴퓨터 간에 정보를 주고받을 때의 통신 방법에 대한 규칙이나 표준.



### OSI 7 Layer 모델

 국제표준화기구(ISO)가 1977년에 정의한 국제 통신 표준 규약이다. 네트워크의 기본 구조를 7개 계층으로 나눠서 표준화한 통신 규약으로 현재 다른 모든 통신 규약의 기반이 된다.

`응, 표, 세, 전, 네, 데, 물`

| 계층  | 이름                              | 설명                                                         |
| ----- | --------------------------------- | ------------------------------------------------------------ |
| 7계층 | 응용 계층(Application Layer)      | 사용자가 네트워크에 접근할 수 있도록 서비스를 제공한다.      |
| 6계층 | 표현 계층(Presentation Layer)     | 세션 계층 간의 주고받는 인터페이스를 일관성 있게 제공한다.   |
| 5계층 | 세션 계층(Session Layer)          | 통신 시스템 사용자간의 연결을 유지 및 설정한다.              |
| 4계층 | 전송 계층(Transport Layer)        | 두 호스트 시스템으로부터 발생하는 데이터의 흐름을 제공한다.  |
| 3계층 | 네트워크 계층(Network Layer)      | 패킷을 네트워크 간의 IP를 통하여 데이터를 전달, 장비로는 라우팅이 존재한다. |
| 2계층 | 데이터 링크 계층(Data Link Layer) | 송/수신을 확인. MAC Address를 가지고 통신. 장비로는 브릿지와 스위치가 존재한다. |
| 1계층 | 물리 계층(Physical Layer)         | 시스템 간의 물리적인 연결과 전기 신호를 변환 및 제어한다.    |



###  TCP/IP(Internet Protocol Suite)

 OSI 모델 7계층의 네트워크에서 데이터를 전송하는 과정을 4개 계층으로 단순화시켜 사용하는 모델이다. 인터넷 모델이라고도 한다.

| 계층                 | 설명                                                         |
| -------------------- | ------------------------------------------------------------ |
| 응용 계층            | OSI 7계층의 세션 계층, 표현 계층, 응용 계층에 해당한다. TCP/UDP 기반의 응용 프로그램을 구현할 때 사용한다. 프로토콜 - FTP, HTTP, SSH |
| 전송 계층            | OSI 7 계층의 전송 계층에 해당한다. 통신 노드간의 연결을 제어하고 신뢰성있는 데이터 전송을 담당한다. 프로토콜 - TCP, UDP |
| 인터넷 계층          | OSI 7계층의 네트워크 계층에 해당한다. 통신 노드 간의 IP패킷을 전송하는 기능과 라우팅 기능을 담당한다. 프로토콜 – IP, ARP, RARP |
| 네트워크 엑세스 계층 | OSI 7계층의 물리계층과 데이터 링크 계층에 해당한다. 물리적인 주소로 MAC을 사용한다. LAN, 패킷망, 등에 사용된다. |



### TCP(Transmission Control Protocol)

 연결형 서비스를 지원하는 전송 계층 프로토콜. 인터넷 환경에서 기본으로 사용한다. 호스트간 신뢰성 있는 데이터 전달과 흐름제어 및 혼잡제어 등을 제공하는 전송 계층이다.

> 특징

-  가상 회선 연결 방식.
-  높은 신뢰성
-  연결의 설정(3-way handshaking)과 해제(4-way handshaking)
-  데이터 흐름 제어(수신자 버퍼 오버플로우 방지) 및 혼잡 제어(네트워크 내 패킷 수가 과도하게 증가하는 현상 방지)
-  전이중(Full-Duplex), 점대점(Point to Point) 서비스

> 소켓 통신 과정

- 서버: 소켓을 생성, 주소 할당, 연결 요청 기다림, 요청에 대한 응답
- 클라이언트: 소켓을 생성, 주소 할당, 연결 요청



### UDP(User Datagram Protocol)

 비연결형 서비스를 지원하는 전송 계층 프로토콜. 인터넷상에서 서로 정보를 주고받을 때 정보를 보낸다는 신호나 받는다는 신호 절차를 거치지 않고, 보내는 쪽에서 일방적으로 데이터를 전달하는 통신 프로토콜. 보내는 쪽에서는 받는 쪽이 데이터를 받았는지 아닌지 확인하지 않는다.

> 특징

- 비연결형(Port만 확인하여 소켓을 식별하고 송수신한다)
- 패킷 오버헤드가 적어 네트워크 부하 감소
- 비신뢰성
- TCP의 Handshaking 같은 연결 성정이 없음

> 소켓 통신 과정

- 서버: 소켓을 생성, 주소 할당, 데이터를 송수신
- 클라이언트: 소켓 생성 후 데이터 수신

|             | TCP                                                          | UDP                                                          |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 연결 방식   | 연결형 프로토콜<br />연결 후 통신<br />1:1 통신 방식         | 비연결형 프로토콜<br />연결없이 통신<br />1:1, 1:N, N:N 통신 방식 |
| 특징        | - 데이터의 경계를 구분 안함<br />- 신뢰성 있는 데이터 전송<br />- 데이터의 전송 순서 보장<br />- 데이터의 수신 여부 확인<br />- 패킷을 관리할 필요 없음<br />- UPD보다 전송 속도가 느림 | - 데이터의 경계를 구분 함<br />- 신뢰성 없는 데이터 전송<br />- 데이터의 전송 순서가 바뀔 수 있음<br />- 데이터의 수신 여부를 확인 안함<br />- 패킷을 관리해야 함<br />- TCP보다 전송 속도가 빠름 |
| 관련 클래스 | .Socker<br />.ServerSocket                                   | .DatagramSocker<br />.DatagramPacket<br />.MulticastSocket   |



### 캡슐화/역캡슐화(encapsulation/ decapsulation)

 캡슐화는 컴퓨터 통신에서 상위 계층의 통신 프로토콜 정보를 데이터에 추가하여 하위 계층으로 전송하는 기술이다. 반대로 역캡슐화는 상위 계층의 통신 프로토콜에서 하위 계층에서 추가한 정보와 데이터를 분리하는 기술이다.



### 헤더(Header)

 저장되거나 전송되는 데이터의 맨 앞에 위치하는 추가적인 정보 데이터다. 데이터의 내용이나 성격을 식별 또는 제어하는 데 사용한다.



### API(Application Programming Interface)

  API는 응용 프로그램(본인이 제작하는 프로그램)에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능(카카오 지도 API, 페이스북 소셜로그인 API)을 제어할 수 있게 만든 인터페이스를 말한다. 어떤 특정 사이트에서 특정 데이터를 공유할 경우 어떠한 방식으로 정보를 요청해야하는지 그리고 어떠한 데이터를 제공 받을 수 있을지에 대한 규격들을 뜻한다.



### 동기(synchronous)와 비동기(asynchronous)

 동기는 말 그대로 동시에 일어난다는 말이다. 요청과 그 결과가 동시에 일어난다는 약속이다. 바로 요청을 하면 시간이 얼마나 걸리든 요청한 자리에서 결과가 주어져야 한다(트랜잭션이 일치). 설계가 간단하고 직관적이지만, 결과가 주어질 때까지 대기해야한다.

 비동기는 동시에 일어나지 않는다는 말이다. 요청과 동시에 결과가 주어지지 않는다(트랜잭션이 불일치). 설계가 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 다른 작업을 할 수 있으므로 자원을 효율적으로 관리할 수 있다.



### Preflight Request

 Preflight Request는 actual 요청 전에 인증 헤더를 전송하여 서버의 허용 여부를 미리 체크하는 테스트 요청이다.



### 브라우저 작동 방식(간단)

> 브라우저의 핵심 기능

사용자가 참조하고자 하는 웹페이지를 서버에 요청(Request)하고 서버의 응답(Response)를 받아 브라우저에 표시하는 것이다.

> 브라우저 기본 구조

1. `사용자 인터페이스` - 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.
2. `브라우저 엔진` - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어.
3. `렌더링 엔진` - 요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시함.
4. `통신 `- HTTP 요청과 같은 네트워크 호출에 사용됨. 이것은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행됨.
5. `UI 백엔드` - 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용.
6. `자바스크립트 해석기` - 자바스크립트 코드를 해석하고 실행.
7. `자료 저장소` - 이 부분은 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 '[웹](http://www.html5rocks.com/en/features/storage)[ ](http://www.html5rocks.com/en/features/storage)[데이터](http://www.html5rocks.com/en/features/storage)[ ](http://www.html5rocks.com/en/features/storage)[베이스](http://www.html5rocks.com/en/features/storage)'가 정의되어 있다.

> HTML, CSS 처리 과정

1. 브라우저는 서버로부터 HTML, CSS, Javascript, 이미지 파일 등을 응답 받는다.
2. HTML, CSS 파일은 `렌더링 엔진`의 `HTML파서`와 `CSS파서`에 의해 `파싱(parsing)`되어 `DOM`, `CSSOM` 트리로 변환되고 `렌더 트리`로 결합된다.
3. 이렇게 생성된 `렌더 트리`를 기반으로 브라우저는 웹 페이지를 표시한다.

> 자바스크립트 처리 과정

1. `HTML 파서`는 `script 태그`를 만나면 자바스크립트 코드를 실행하기 위해 `DOM 생성 프로세스를 중지`하고 `자바스크립트 엔진`으로 제어 권한을 넘긴다.
2. 제어 권한을 넘겨 받은 `자바스크립트 엔진`은 `script 태그 내`의 자바스크립트 코드 또는 script 태그의 src attribute에 정의된 `자바스크립트 파일을 로드하고 파싱하여 실행`한다.
3. 자바스크립트의 실행이 완료되면 다시 `HTML 파서`로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다.



### 쿠키와 세션

> HTTP의 특징과 쿠키와 세션을 사용하는 이유

- HTTP 프로토콜의 특징이자 약점을 보완하기 위해서 사용한다.
- HTTP 프로토콜 환경에서 서버는 클라이언트가 누구인지 확인해야합니다. 그 이유는 HTTP 프로토콜이 connectionless(클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어 버리는 특징), stateless(통신이 끝나면 상태를 유지하지 않는 특징)한 특성이 있기 때문입니다.

쿠키와 세션은 위의 두 가지 특징을 해결하기 위해 사용합니다.

예를 들어, 쿠키와 세션을 사용하지 않으면 쇼핑몰에서 옷을 구매하려고 로그인을 했음에도, 페이지를 이동할 때 마다 계속 로그인을 해야 합니다. 쿠키와 세션을 사용했을 경우, 한 번 로그인을 하면 어떠한 방식에 의해서 그 사용자에 대한 인증을 유지하게 됩니다.

> 쿠키

쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일입니다.

사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있습니다. 쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조합니다.

> 쿠키의 동작 방식

1. 클라이언트가 페이지를 요청
2. 서버에서 쿠키를 생성
3. HTTP 헤더에 쿠키를 포함 시켜 응답
4. 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음
5. 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄
6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답

> 쿠키의 사용 예

- 방문 사이트에서 로그인 시, "아이디와 비밀번호를 저장하시겠습니까?"
- 쇼핑몰의 장바구니 기능
- 자동로그인, 팝업에서 "오늘 더 이상 이 창을 보지 않음" 체크, 쇼핑몰의 장바구니

>  세션이란?

- 세션은 쿠키를 기반하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버 측에서 관리합니다.
- 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지합니다.
- 물론 접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정이 가능 합니다.
- 사용자에 대한 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지하게 됩니다.
- 즉 동접자 수가 많은 웹 사이트인 경우 서버에 과부하를 주게 되므로 성능 저하의 요인이 됩니다.
- 클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는 데 이것이 세션ID다.

>  세션의 동작 방식

1. 클라이언트가 서버에 접속 시 세션 ID를 발급받습니다.
2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있습니다.
3. 클라리언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 서버에 전달해서 사용합니다.
4. 서버는 세션 ID를 전달 받아서 별다른 작업없이 세션 ID로 세션에 있는 클라언트 정보를 가져옵니다.
5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답합니다.

>  세션의 특징

- 각 클라이언트에게 고유 ID를 부여
- 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
- 보안 면에서 쿠키보다 우수
- 사용자가 많아질수록 서버 메모리를 많이 차지하게 됨

> 세션의 사용 예

- 로그인 같이 보안상 중요한 작업을 수행할 때 사용

>  쿠키와 세션의 차이

- 쿠키와 세션은 비슷한 역할을 하며, 동작원리도 비슷합니다. 그 이유는 세션도 결국 쿠키를 사용하기 때문입니다.
- 가장 큰 차이점은 사용자의 정보가 저장되는 위치입니다. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다.
- 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠릅니다. 그 이유는 세션은 서버의 처리가 필요하기 때문입니다.
- 보안, 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만 세션은 쿠키를 이용해서 sessionid 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋습니다.
- 라이프 사이클, 쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있다.
- 반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.
- 속도, 쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 낸다.

출처: https://interconnection.tistory.com/74 [라이언 서버]



### JWT(JSON Web Token)

 JWT란 JSON 포맷을 이용하여 사용자에 대한 속성을 저장하는 Claim 기반의 Web Token이다. JWT는 토큰 자체를 정보로 사용하는 Self-Contained 방식으로 정보를 안전하게 전달한다. 주로 회원 인증이나 정보 전달에 사용되는 JWT는 아래 로직으로 처리된다.

1. 어플리케이션이 실행될 때 JWT를 static 변수와 로컬 스토리지에 저장한다. static 변수에 저장되는 이유는 HTTP 통신을 할 때 마다 JWT를 HTTP 헤더에 담아서 보내야 하는데, 이를 로컬 스토리지에서 계속 불러오면 오버헤드가 발생하기 때문이다.
2. JWT를 포함해 요청을 보내면 서버는 허가된 JWT인지 검사한다.
3. 로그아웃을 할 경우 로컬 스토리지에 저장된 JWT를 제거한다. (실제 서비스의 경우에는 사용했던 토큰을 blacklist라는 DB 테이블에 넣어 해당 토큰의 접근을 막는 작업을 해주어야 한다)

JWT는 Header, Payload, Signature의 3부분으로 이루어진다.

- Header: 헤더는 typ와 alg 두 가지 정보로 구성된다.
  - typ: 토큰의 타입을 지정
  - alg: 알고리즘 방식을 지정
- Payload: 토큰에서 사용할 정보의 조각들인 클레임(Claim)이 담겨 있다. BASE64로 인코딩.
- Signature: Signature는 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 고유한 암호화 코드이다.

> 장점

1. 사용자 인증에 필요한 모든 정보는 토큰 자체에 포함하기 때문에 별도의 인증 저장소가 필요없다.

> 단점

1. Self-contained: 토큰 자체에 정보를 담고 있으므로 보안에 취약할 수 있다.
2. 토큰 길이: 3종류의 클레임을 저장하기 때문에 정보가 많아질수록 길이가 늘어나 네트워크에 부하를 줄 수 있다.
3. Payload 인코딩: Payload 자체가 암호화된 것이 아니라 BASE64로 인코딩된 것이므로 Payload를 탈취하여 디코딩하면 데이터를 볼 수 있다.



### HTTP(HyperText Transfer Protocol) vs HTTPS(+ Secure)

HTTP는 하이퍼 텍스트 전송 프로토콜의(Hypertext Transfer Protocol)의 약자입니다. 서로 다른 시스템들 사이에서 통신을 주고받게 해주는 가장 기초적인 프로토콜인데요. 여러분이 웹 서핑을 할 때 서버에서 여러분의 브라우저로 데이터를 전송해 주는 용도로 가장 많이 사용됩니다. 그리고 인터넷의 초기에 모든 웹사이트에서 기본적으로 사용되었던 프로토콜이기도 하죠.

HTTPS는 하이퍼 텍스트 전송 프로토콜 보안(Hypertext Transfer Protocol Secure)의 약자입니다. 일반 HTTP 프로토콜의 문제점은 서버에서부터 브라우저로 전송되는 정보가 암호화되지 않는다는 것이었는데요. 이 말은 즉, 데이터가 쉽게 도난당할 수 있다는 것이었습니다. HTTPS 프로토콜은 SSL(보안 소켓 계층)을 사용함으로써 이 문제를 해결했습니다. SSL은 서버와 브라우저 사이에 안전하게 암호화된 연결을 만들 수 있게 도와주고, 서버 브라우저가 민감한 정보를 주고받을 때 이것이 도난당하는 것을 막아줍니다.

두 프로토콜 사이에 가장 커다란 차이점은 바로 SSL 인증서입니다. 사실 HTTPS는 쉽게 말해서 HTTP 프로토콜에 보안 기능을 추가한 것이라고 말할 수 있는데요. 보안 기능은 생각보다 매우 중요합니다. 특히 신용카드 정보나 비밀번호 등 사용자들의 민감한 정보들을 다루는 웹사이트에서라면 더욱 그렇죠.

SSL 인증서는 사용자가 사이트에 제공하는 정보를 암호화하는데, 쉽게 말해서 데이터를 암호로 바꾼다고 생각하면 쉽습니다. 이렇게 전송된 데이터는 중간에서 누군가 훔쳐 낸다고 하더라도 데이터가 암호화되어있기 때문에 해독할 수 없습니다. 그 외에도 HTTPS는 TLS(전송 계층 보안) 프로토콜을 통해서도 보안을 유지합니다. TSL은 데이터 무결성을 제공하기 때문에 데이터가 전송 중에 수정되거나 손상되는 것을 방지하고, 사용자가 자신이 의도하는 웹사이트와 통신하고 있음을 입증하는 인증 기능도 제공하고 있습니다.



### HTTP status(response) code

| **Response Class Code** | **Response Class 의미**        | **설명**                                   |
| ----------------------- | ------------------------------ | ------------------------------------------ |
| 1                       | Informational (정보)           | 리퀘스트를 받고, 처리 중에 있음.           |
| 2                       | Success (성공)                 | 리퀘스트를 정상적으로 처리함.              |
| 3                       | Redirection (리디렉션)         | 리퀘스트 완료를 위해 추가 동작이 필요함.   |
| 4                       | Client Error (클라이언트 오류) | 클라이언트 요청을 처리할 수 없어 오류 발생 |
| 5                       | Server Error (서버 오류)       | 서버에서 처리를 하지 못하여 오류 발생      |

>  200 번대 응답(Response) : 성공(Success)

| 200  | OK              | * 요청 정상 처리.                                            |
| ---- | --------------- | ------------------------------------------------------------ |
| 204  | No Content      | * 요청 정상 처리하였지만, 돌려줄 리소스 없음.* 응답에 어떠한 엔티티 바디(Entity Body)도 포함하지 않음.* 서버에서 처리 후, 클라이언트에 정보를 보낼 필요가 없는 경우 사용. |
| 206  | Partial Content | * Range가 지정된 요청인 경우, 지정된 범위만큼의 요청을 받았다는 것을 알려줌. |

> 300 번대 응답(Response) : 리디렉션(Redirection)

| 301  | Moved Permanently  | * 요청된 리소스에는 새로운 URI가 지정되어 있기 때문에, 이후로는 새 URI를 사용해야 한다는 것을 나타냄. (영구적인 URI 변경) |
| ---- | ------------------ | ------------------------------------------------------------ |
| 302  | Found              | * 요청된 리소스에는 새로운 URI가 지정되어 있기 때문에, 이후로는 새 URI를 사용해야 한 다는 것을 나타냄. 301과 유사하지만, 302는 일시적인 URI 이동) |
| 303  | See Other          | * 이 응답은 요청에 대한 리소스는 다른 URI에 있기 때문에 GET 메서드를 사용해서 얻어야 한다는 것을 나타냄. 302 코드와 같지만, 303은 리디렉션 위치를 GET 메서드를 통해 얻어야 한다고 명확하게 되어 있음. |
| 304  | Not Modified       | * 요청한 리소스가 마지막 요청 이후 변경된 적이 없기 때문에 기존 클라이언트의 로컬 캐시 리소스를 사용하도록 알려줌.300번대로 분류되어 있지만, 리디렉션과는 관계없는 처리를 함. |
| 307  | Temporary Redirect | * 임시로 페이지를 리다이렉트 함.                             |

>  400 번대 응답(Response) : 클라이언트 에러 (Client Error)

| 400  | Bad Request        | * 클라이언트의 요청 구문이 잘못됨.* 브라우저는 이 응답을 200 OK 응답과 동일한 형태로 취급함. |
| ---- | ------------------ | ------------------------------------------------------------ |
| 401  | Unauthorized       | * 요청 처리를 위해 HTTP 인증(BASIC 인증, DIGEST 인증) 정보가 필요함을 알려줌.접근 허용을 차단함. 최초 요청에는 인증 다이얼로그 표시하고, 두번째는 인증 실패 응답을 보냄. |
| 403  | Forbidden          | * 접근 금지 응답. Directory Listing 요청(서버 파일 디렉토리 목록 표시) 및 관리자 페이지 접근 등을 차단하는 경우의 응답. (파일 시스템 퍼미션 거부, 허가 되지 않은 IP 주소를 통한 액세스의 거부 등)* 서버는 엔티티 바디에 접근 거부에 대한 이유를 명시하여 보낼 수 있음. |
| 404  | Not Found          | * 클라이언트가 요청한 리소스가 서버에 없음                   |
| 405  | Mothod Not Allowed | * 허용되지 않는 HTTP 메서드를 사용함.                        |

> 500 번대 응답(Response) : 서버 에러 (Server Error)

| 500  | Internal Server Error      | * 서버에서 클라이언트 요청을 처리 중에 에러가 발생함.        |
| ---- | -------------------------- | ------------------------------------------------------------ |
| 503  | Service Unavailable        | * 서버가 일시적으로 요청을 처리할 수 없음.* 서버가 과부하 상태이거나 점검중이므로 요청을 처리할 수 없음을 알려줌. |
| 504  | Gateway Timeout            | * 서버를 통하는 게이트웨이에 문제가 발생하여 시간이 초과됨.  |
| 505  | HTTP Version Not Supported | * 해당 HTTP 버전에서는 지원되지 않는 요청임을 알려줌         |



### CORS

 도메인 또는 포트가 다른 서버의 자원을 요청하는 매커니즘.

 CORS(Cross-origin Resource Sharing)은 추가적인 HTTP Header를 사용해서 어플리케이션이 다른 origin의 리소스에 접근할 수 있도록 하는 메커니즘을 말합니다. 하지만 다른 origin에서 내 리소스에 함부로 접근하지 못하게 하기 위해 사용된다.

>  요청 헤더 목록

- Origin
- Access-Control-Request-Method: `preflight`요청을 할 때 실제 요청에서 어떤 메서드를 사용할 것인지 서버에게 알리기 위해 사용
- Access-Control-Request-Headers: `preflight` 요청을 할 때 실제 요청에서 어떤 header를 사용할 것인지 서버에게 알리기 위해 사용

> 응답 헤더 목록

- Access-Control-Allow-Origin: 브라우저가 해당 origin이 자원에 접근할 수 있도록 허용합니다. 혹은 *은 credentials이 없는 요청에 한해서 모든 origin에서 접근이 가능하도록 허용합니다.

> 필요한 이유

 내가 서비스하고 있지 않은 사이트에서 세션을 요청해서 세션을 획득할 수 있다면 해당 사이트는 악의적으로 내 세션을 탈취하거나 다른 행동을 할 수 있습니다. 그래서 브라우저에서는 이러한 요청을 막습니다. 내가 허용한 origin들만 요청할 수 있도록 하기 위해 필요합니다.

> CORS 작동 방식

 브라우저가 리소스를 요청할 때 추가적인 헤더에 정보를 담습니다. 내 origin은 무엇이고 어떤 메소드를 사용해서 요청을 할 것이고 어떤 헤더들을 포함할 것인지를 담아서 서버에 전송합니다. 서버는 서버가 응답할 수 있는 origin들을 헤더에 담아서 브라우저에게 보냅니다. 브라우저가 이 헤더를 보고 해당 origin에서 요청할 수 있다면 리소스 전송을 허용하고 만약 불가능하다면 에러를 발생시킵니다.

[제일 이해가 쉬운 글](https://velog.io/@wlsdud2194/cors)

### 3-way Handshake & 4-way Handshake

 3-way Handshake는 TCP/IP 프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.

1. A 클라이언트는 B 서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 A 클라이언트는 SYN을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태가 된다.
2. B 서버는 SYN 요청을 받고 A 클라이언트에게 요청을 수락한다는 ACK와 SYN flag가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다. 이때 B 서버는 SYN_RECEIVED 상태가 된다.
3. A 클라이언트는 B서버에게 ACK을 보내고 이후 연결이 이루어지고 데이터가 오간다. 이때의 B 서버의 상태는 ESTABLISHED이다.

 4-way Handshake는 세션을 종료하기 위해 수행되는 절차이다.

1. 클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송한다.
2. 서버는 확인 메세지를 보내고 자신의 통신이 끝날 때 까지 기다리는 TIME_WAIT 상태를 갖는다.
3. 서버가 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN 플래그를 전송한다.
4. 클라이언트는 확인했다는 메세지를 보낸다.



### Payload

`payload`란 `전송되는 데이터`를 의미한다. `payload` 단어는 운송업에서 비롯되었는데, 적재된 운송 물품(load)에 대해서만 그 비용을 지불(pay)한다는 의미이다. 
API 요청으로 response가 반환되었을 때, response에 있는 header, status, method 등을 제외한 data 정보만을 payload라 칭한다. 