# 컴퓨터 CS 정리

## Python





## Java

### Garbage Collection

 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요없게 된 영역을 해제하는 기능이다.

장점

- 프로그래머가 동적으로 할당한 메모리 영역의 전체를 완벽하게 관리할 필요가 없어진다.
- 유효하지 않은 포인터에 접근하지 않는다. 따라서 이중 해제 문제점도 없어진다.
- 더 이상 필요하지 않은 메모리가 해제되고 메모리 누수가 없어진다.

단점

- 어떤 메모리를 해제할지 결정하는 데 비용이 든다.
- 할당된 메모리가 해제되는 시점을 알 수 없다.



## OOP

### 객체지향프로그래밍

 객체지향 프로그래밍(Object-Oriented Programming)이란 문제를 여러 개의 객체 단위로 나눠 작업하는 방식을 말합니다. 클래스를 이용해 연관있는 데이터 부분(변수)과 처리 부분(함수)를 하나로 묶어 객체(인스턴스)를 생성해 사용한다는 점입니다.

장점

- 코드 재사용성이 용이
- 유지보수가 쉽다
- 대규모 프로젝트에 적합하다

단점

- 처리 속도가 느리다
- 객체에 따른 용량이 증가한다
- 설계에 시간이 많이 소요된다.



### 추상화(Abstraction)

 객체지향에서 추상화란 객체에서 공통된 속성과 행위를 추출하는 것을 의미한다.

 예를들어, 게임 프로그램을 개발하며 캐릭터가 소지하는 다양한 무기들이 있다. 칼, 삽, 곡갱이, 총, 활 등 여러가지 무기들이 존재하는데, 이들의 기능적인 내용은 다르지만 공통적인 속성과 행위를 개념으로 무기라는 클래스를 정의할 수 있다. 이렇듯 추상화는 다른 객체들과 구분되는 핵심적인 부분에 집중하여, 복잡도를 관리할 수 있게 해준다.



### 캡슐화(Encapsulation)

 캡슐화는 연관있는 변수와 메소드를 묶어주는 작업을 말한다.

 접근 제어 지시자[public, private, protected]를 통해 외부로부터의 접근을 제한하여 객체내에서만 접근이 가능하도록 해주며 이를 정보은닉이라 한다. 외부의 클래스 혹은 모듈에 의존적인 프로그램의 경우 변경이나 오류에 취약해지는데, 정보은닉을 통해 이러한 결합도를 낮추며 응집도를 높여준다.



### 상속(Inheritance)

 클래스 개념이 도입되면서 상속을 통해 부모클래스의 속성과 기능을 이어받아 사용하는 것을 말한다.

 프로그램을 개발하다보면 중복되는 속성과 기능을 개발해야하는 일이 발생되는데 상속을 사용한다면 중복되는 기능을 반복하여 작업하지 않고 작업을 할 수 있게 해준다. 자식클래스는 상속을 통해 부모클래스의 속성과 기능을 물려받는다.

 또한, 다형성을 통해 변경이 필요한 부분을 변경하여 사용할 수 있다.



### 다형성(Polymorphism)

 다형성이란 프로그래밍 언어의 자료형 체계의 성질을 나타내는 것으로, 동일한 변수, 함수명 등이 다양한 방법으로 기능하는 것을 말하며 오버라이딩(Overriding), 오버로딩(Overloading)이란 형태로 제공된다.



### 오버라이딩(Overriding), 오버로딩(Overloading)

 오버라이딩은 상위 클래스가 갖고 있는 메서드를 하위 클래스가 상속해 재정의해서 사용하는 것이다. 오버로딩은 메서드 오버로딩과 생성자 오버로딩이 있으며, 같은 이름의 함수를 여러개 정의하고, 매개변수의 유형과 개수를 다르게 하여 다양한 유형의 호출에 응답할 수 있게 하는 것이다. 



## OS

### 프로세스와 스레드

  프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고 스레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위입니다. 프로세스는 실행될 때 운영체제로부터 프로세서, 필요한 주소 공간, 메모리 등 자원을 할당받습니다. 스레드란 한 프로세스 내에서 동작되는 여러 실행의 흐름으로 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내에 스레드끼리 공유하면서 실행됩니다.

 그렇다면 왜 멀티 프로세스로 할 수 있는 작업들을 굳이 하나의 프로세스에서 스레드로 나눠가면서 할까요? 이유는 간단합니다. 운영체제는 시스템 자원을 효율적으로 관리하기 위해서 스레드를 사용하는 것입니다. 

 자세히 말하면 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다. 뿐만 아니라 프로세스 간의 통신보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어들게 됩니다.

 이처럼 스레드를 활용하면 자원의 효율성이 증가하기도 하지만 스레드 간의 자원 공유는 전역 변수를 이용하므로 동기화 문제에 신경을 써야 합니다.





## 자료구조, 알고리즘

### 퀵 소트

### 병합정렬





## 데이터베이스

### ORM(Object Relational Mapping)

 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 것을 말한다. 객체지향프로그래밍은 클래스를 사용하고, 관계형 데이터베이스는 테이블을 사용한다. 객체 모델과 관계형 모델 간에 불일치가 존재하는데 ORM을 통해 객체 관의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결한다.



## 네트워크

### 패킷(packet)

 네트워크 통신을 할 때 사용되는 작게 분할된 데이터 조각으로 네트워크에서 전송하는 데이터의 기본 단위이다.



### 인터넷 서비스 제공자(ISP, Internet Service Provider)

 인터넷에 접속하는 수단을 제공하는 주체다. 일반 사용자, 기업체, 기관, 단체 등이 인터넷에 접속하여 인터넷을 이용할 수 있도록 돕는 사업자다(KT, U+, SK브로드밴드 등).



### 프로토콜

 컴퓨터 간에 정보를 주고받을 때의 통신 방법에 대한 규칙이나 표준.



### OSI 모델

 국제표준화기구(ISO)가 1977년에 정의한 국제 통신 표준 규약이다. 네트워크의 기본 구조를 7개 계층으로 나눠서 표준화한 통신 규약으로 현재 다른 모든 통신 규약의 기반이 된다.

`응, 표, 세, 전, 네, 데, 물`

| 계층  | 이름                              | 설명                                                         |
| ----- | --------------------------------- | ------------------------------------------------------------ |
| 7계층 | 응용 계층(Application Layer)      | 이메일, 파일 전송, 웹사이트 조회 등 어플리케이션에 대한 서비스를 제공한다. |
| 6계층 | 표현 계층(Presentation Layer)     | 문자 코드, 압축, 암호화 등의 데이터를 변환한다.              |
| 5계층 | 세션 계층(Session Layer)          | 세션 체결, 통신 방식을 결정한다.                             |
| 4계층 | 전송 계층(Transport Layer)        | 신뢰할 수 있는 통신을 구현한다.                              |
| 3계층 | 네트워크 계층(Network Layer)      | 다른 네트워크와 통신하기 위한 경로 설정 및 논리 주소를 결정한다. |
| 2계층 | 데이터 링크 계층(Data Link Layer) | 네트워크 기기 간의 데이터 전송 및 물리 주소를 결정한다.      |
| 1계층 | 물리 계층(Physical Layer)         | 시스템 간의 물리적인 연결과 전기 신호를 변환 및 제어한다.    |



###  TCP/IP(Internet Protocol Suite)

 OSI 모델 7계층의 네트워크에서 데이터를 전송하는 과정을 4개 계층으로 단순화시켜 사용하는 모델이다. 인터넷 모델이라고도 한다.

| 계층               | OSI 모델 매칭                   |
| ------------------ | ------------------------------- |
| 응용 계층          | 응용 계층, 표현 계층, 세션 계층 |
| 전송 계층          | 전송 계층                       |
| 인터넷 계층        | 네트워크 계층                   |
| 네트워크 접속 계층 | 데이터 링크 계층, 물리 계층     |



### 캡슐화/역캡슐화(encapsulation/ decapsulation)

 캡슐화는 컴퓨터 통신에서 상위 계층의 통신 프로토콜 정보를 데이터에 추가하여 하위 계층으로 전송하는 기술이다. 반대로 역캡슐화는 상위 계층의 통신 프로토콜에서 하위 계층에서 추가한 정보와 데이터를 분리하는 기술이다.



### 헤더(Header)

 저장되거나 전송되는 데이터의 맨 앞에 위치하는 추가적인 정보 데이터다. 데이터의 내용이나 성격을 식별 또는 제어하는 데 사용한다.



### API(Application Programming Interface)

 API는 응용 프로그램(본인이 제작하는 프로그램)에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능(카카오 지도 API, 페이스북 소셜로그인 API)을 제어할 수 있게 만든 인터페이스를 말한다. 어떤 특정 사이트에서 특정 데이터를 공유할 경우 어떠한 방식으로 정보를 요청해야하는지 그리고 어떠한 데이터를 제공 받을 수 있을지에 대한 규격들을 뜻한다.



### 동기(synchronous)와 비동기(asynchronous)

 동기는 말 그대로 동시에 일어난다는 말이다. 요청과 그 결과가 동시에 일어난다는 약속이다. 바로 요청을 하면 시간이 얼마나 걸리든 요청한 자리에서 결과가 주어져야 한다(트랜잭션이 일치). 설계가 간단하고 직관적이지만, 결과가 주어질 때까지 대기해야한다.

 비동기는 동시에 일어나지 않는다는 말이다. 요청과 동시에 결과가 주어지지 않는다(트랜잭션이 불일치). 설계가 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 다른 작업을 할 수 있으므로 자원을 효율적으로 관리할 수 있다.



### Preflight Request

 Preflight Request는 actual 요청 전에 인증 헤더를 전송하여 서버의 허용 여부를 미리 체크하는 테스트 요청이다.



### JWT(JSON Web Token)

 JWT란 JSON 포맷을 이용하여 사용자에 대한 속성을 저장하는 Claim 기반의 Web Token이다. JWT는 토큰 자체를 정보로 사용하는 Self-Contained 방식으로 정보를 안전하게 전달한다. 주로 회원 인증이나 정보 전달에 사용되는 JWT는 아래 로직으로 처리된다.

1. 어플리케이션이 실행될 때 JWT를 static 변수와 로컬 스토리지에 저장한다. static 변수에 저장되는 이유는 HTTP 통신을 할 때 마다 JWT를 HTTP 헤더에 담아서 보내야 하는데, 이를 로컬 스토리지에서 계속 불러오면 오버헤드가 발생하기 때문이다.
2. JWT를 포함해 요청을 보내면 서버는 허가된 JWT인지 검사한다.
3. 로그아웃을 할 경우 로컬 스토리지에 저장된 JWT를 제거한다. (실제 서비스의 경우에는 사용했던 토큰을 blacklist라는 DB 테이블에 넣어 해당 토큰의 접근을 막는 작업을 해주어야 한다)

JWT는 Header, Payload, Signature의 3부분으로 이루어진다.

- Header: 헤더는 typ와 alg 두 가지 정보로 구성된다.
  - typ: 토큰의 타입을 지정
  - alg: 알고리즘 방식을 지정
- Payload: 토큰에서 사용할 정보의 조각들인 클레임(Claim)이 담겨 있다. BASE64로 인코딩.
- Signature: Signature는 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 고유한 암호화 코드이다.

> 장점

1. 사용자 인증에 필요한 모든 정보는 토큰 자체에 포함하기 때문에 별도의 인증 저장소가 필요없다.

> 단점

1. Self-contained: 토큰 자체에 정보를 담고 있으므로 보안에 취약할 수 있다.
2. 토큰 길이: 3종류의 클레임을 저장하기 때문에 정보가 많아질수록 길이가 늘어나 네트워크에 부하를 줄 수 있다.
3. Payload 인코딩: Payload 자체가 암호화된 것이 아니라 BASE64로 인코딩된 것이므로 Payload를 탈취하여 디코딩하면 데이터를 볼 수 있다.



### CORS

 CORS(Cross-origin Resource Sharing)은 추가적인 HTTP Header를 사용해서 어플리케이션이 다른 origin의 리소스에 접근할 수 있도록 하는 메커니즘을 말합니다. 하지만 다른 origin에서 내 리소스에 함부로 접근하지 못하게 하기 위해 사용된다.

>  요청 헤더 목록

- Origin
- Access-Control-Request-Method: `preflight`요청을 할 때 실제 요청에서 어떤 메서드를 사용할 것인지 서버에게 알리기 위해 사용
- Access-Control-Request-Headers: `preflight` 요청을 할 때 실제 요청에서 어떤 header를 사용할 것인지 서버에게 알리기 위해 사용

> 응답 헤더 목록

- Access-Control-Allow-Origin: 브라우저가 해당 origin이 자원에 접근할 수 있도록 허용합니다. 혹은 *은 credentials이 없는 요청에 한해서 모든 origin에서 접근이 가능하도록 허용합니다.

> 필요한 이유

 내가 서비스하고 있지 않은 사이트에서 세션을 요청해서 세션을 획득할 수 있다면 해당 사이트는 악의적으로 내 세션을 탈취하거나 다른 행동을 할 수 있습니다. 그래서 브라우저에서는 이러한 요청을 막습니다. 내가 허용한 origin들만 요청할 수 있도록 하기 위해 필요합니다.

> CORS 작동 방식

 브라우저가 리소스를 요청할 때 추가적인 헤더에 정보를 담습니다. 내 origin은 무엇이고 어떤 메소드를 사용해서 요청을 할 것이고 어떤 헤더들을 포함할 것인지를 담아서 서버에 전송합니다. 서버는 서버가 응답할 수 있는 origin들을 헤더에 담아서 브라우저에게 보냅니다. 브라우저가 이 헤더를 보고 해당 origin에서 요청할 수 있다면 리소스 전송을 허용하고 만약 불가능하다면 에러를 발생시킵니다.



### 3-way Handshake & 4-way Handshake

 3-way Handshake는 TCP/IP 프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.

1. A 클라이언트는 B 서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 A 클라이언트는 SYN을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태가 된다.
2. B 서버는 SYN 요청을 받고 A 클라이언트에게 요청을 수락한다는 ACK와 SYN flag가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다. 이때 B 서버는 SYN_RECEIVED 상태가 된다.
3. A 클라이언트는 B서버에게 ACK을 보내고 이후 연결이 이루어지고 데이터가 오간다. 이때의 B 서버의 상태는 ESTABLISHED이다.

 4-way Handshake는 세션을 종료하기 위해 수행되는 절차이다.

1. 클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송한다.
2. 서버는 확인 메세지를 보내고 자신의 통신이 끝날 때 까지 기다리는 TIME_WAIT 상태를 갖는다.
3. 서버가 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN 플래그를 전송한다.
4. 클라이언트는 확인했다는 메세지를 보낸다.



데이터베이스, 네트워크, 몇몇 디자인 패턴에 대해 공부해가면 도움이 될 것.
프로젝트 질문(꼬리물기) -> 시스템 아키텍처
네트워크 통신 관련 지식
렌더링?
오케스트레이션?
사이트 반응이 느린 이유? -> 면접자답변: 요청 리소스 로딩시 병목 지점
프로젝트 라이브러리 어떻게 동작하는지
http통신
퀵소트 / 머지소트 설명
도메인입력하고 페이지 열리는데까지 서버에서 하는 일
인덱스란?
좋은 API는 뭘까
서버를 잘 만들려면?
credential / 해당 패킷 암호화
tcp http 7계층
tcp/udp차이
프로세스/ 쓰레드 차이
동기화??
멀티 쓰레드